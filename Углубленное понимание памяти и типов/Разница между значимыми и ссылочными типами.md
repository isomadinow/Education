### Мини-документация: День 2 – Разница между значимыми и ссылочными типами + `ref struct` и `readonly struct`

---

#### **Что изучил:**
1. **Различия между `struct` и `class`:**
   - **`struct` (значимые типы):**
     - Хранятся в стеке.
     - Копируются по значению.
     - Используются для небольших, неизменяемых объектов, где важна производительность.
   - **`class` (ссылочные типы):**
     - Хранятся в куче, а их ссылка — в стеке.
     - Копируются по ссылке.
     - Используются для сложных, изменяемых объектов.

2. **Особенности памяти:**
   - Значимые типы хранятся в стеке, копирование не влияет на оригинал.
   - Ссылочные типы хранятся в куче, изменения через одну ссылку отражаются через все ссылки.

3. **`ref struct`:**
   - Структура, которая работает **только в стеке**.
   - Используется для высокопроизводительных операций, например, в `Span<T>`.
   - Нельзя помещать в коллекции или использовать в классах.

4. **`readonly struct`:**
   - Неизменяемая структура, гарантирует неизменность всех полей.
   - Улучшает читаемость и позволяет компилятору оптимизировать код.
   - Используется для математических и неизменяемых объектов.

---

#### **Примеры кода:**

1. **Различия между `struct` и `class`:**
   ```csharp
   struct Point { public int X; public int Y; }
   class Circle { public int Radius { get; set; } }

   Point point1 = new Point { X = 5, Y = 10 };
   Point point2 = point1;
   point2.X = 20;

   Circle circle1 = new Circle { Radius = 15 };
   Circle circle2 = circle1;
   circle2.Radius = 30;

   Console.WriteLine($"Point1: X={point1.X}, Y={point1.Y}"); // X=5, Y=10
   Console.WriteLine($"Point2: X={point2.X}, Y={point2.Y}"); // X=20, Y=10

   Console.WriteLine($"Circle1 Radius: {circle1.Radius}"); // 30
   Console.WriteLine($"Circle2 Radius: {circle2.Radius}"); // 30
   ```

2. **`ref struct`:**
   ```csharp
   ref struct StackOnlyStruct
   {
       public int Value;
       public StackOnlyStruct(int value)
       {
           Value = value;
       }

       public void Increment()
       {
           Value++;
       }
   }

   class Program
   {
       static void Main()
       {
           Span<int> numbers = stackalloc int[5] { 1, 2, 3, 4, 5 };
           foreach (var num in numbers)
           {
               Console.WriteLine(num);
           }

           StackOnlyStruct stackStruct = new StackOnlyStruct(10);
           stackStruct.Increment();
           Console.WriteLine(stackStruct.Value); // 11
       }
   }
   ```

3. **`readonly struct`:**
   ```csharp
   readonly struct ImmutablePoint
   {
       public readonly int X { get; }
       public readonly int Y { get; }

       public ImmutablePoint(int x, int y)
       {
           X = x;
           Y = y;
       }

       public double DistanceTo(ImmutablePoint other)
       {
           int dx = X - other.X;
           int dy = Y - other.Y;
           return Math.Sqrt(dx * dx + dy * dy);
       }
   }

   class Program
   {
       static void Main()
       {
           ImmutablePoint p1 = new ImmutablePoint(0, 0);
           ImmutablePoint p2 = new ImmutablePoint(3, 4);

           Console.WriteLine($"Distance: {p1.DistanceTo(p2)}"); // 5
       }
   }
   ```

---

#### **Выводы:**
1. Используй **`struct`** для небольших объектов, где важна производительность, и которые не требуют наследования.
2. Используй **`class`** для больших и сложных объектов, где нужны полиморфизм и изменение данных.
3. **`ref struct`** полезен для работы с памятью в стеке и высокопроизводительных операций.
4. **`readonly struct`** обеспечивает неизменяемость и безопасное использование данных.

---

